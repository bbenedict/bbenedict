### 100 days of coding

We're coming to the end of 2023 and my brain is telling me I haven't tried
to learn enough this year.  This happens to me in Nov and by Dec I am working 
on something in anticipation of the inevitable New Year's resolution.

I decided to do a 100 days of coding challenge inspired by a small test project from a few months ago.
I was exploring all the different ways you use prompts with LLMs and ended up creating a unified
completion function that handles system prompts, context, streaming, everything.  Here's sample code 
showing ```get_completion```.  The undescore is the content which can be used when not streaming 
the response.

```
_, messages = get_completion(client,
                             content_callback,
                             user_prompt="Who won the first world series?",
                             system_prompt="Explain this like a child is talking to an adult",
                             stream_response=True
                             )

_, messages = get_completion(client, content_callback, user_prompt="Who was the most valuable player?", messages=messages)

_, messages = get_completion(client, content_callback, user_prompt="Who was the most recent MVP of this?", messages=messages)

```

I began thinking how I might use the code in other ways.  What could you do if you took the output from 
one completion and passed it to another?  And from there, I wondered what I could do with this project?  
My first python package? My first managed open source project? The potential for learning continued to grow, 
which led me to **completion paths**.  A completion path allows you to link together several completions 
generated by third party APIs together passing the results from one step to the next.  

Here's what I am hoping to learn:

* How to start an open source project from scratch
  * How to set up the org, the project, the repo
  * What does a good project look like
  * How do you create docs, manage issues, promote your work
* What are best practices for python package creation and updating
  * What tools do you use to create and deploy a new package
  * How does the CI/CD pipeline factor in
  * What standards like PEP 8 do people follow
* How do you validate a package where a significant portion of the app uses third party APIs
  * How do you create automated tests without driving up costs
  * How do you track if the third party API has changed
* What is the workflow to contibute to an open source project
  * Likely to use an existing project for this part
  * What is key to following the fork and pull request process
* Your live, what's next

Two disclosures before I start.  First, I started this a few days ago.  The first 7 days of this project are 
in the rear view mirror.  Second, my day job is VP, Engineering for Capacity.  A company using AI to help 
support teams do their best work.  The job can get pretty demanding and some days I won't have time for this 
learning experience.  Long story short, the days are not going to be sequential.  But I will hit 100 days at 
some point!

Here we go.  100 days of coding starts now (or did 7 days ago).
  
## day 1

I reviewed the code of the unified completion function and began to map out my plan.  I decided I would need
paths that connect nodes, and each node would need a config to speak with the LLM.  Made a copy of the project
and started re-factoring.

## day 2

First successful execution of the code.  I created a path with two configs, both using OpenAI GPT-4 for completion.
I must admint I created some pretty funny conversations.  One of them I will definitely blog about.  If nothing else,
this package will be a great way to create a dialog between two AI personalities.

## day 3

Looked at some other successful open source projects to see how they were structured.  Also looked at what tools 
they used.  I decided to go with poetry for package management and building.  Was able to do my first build.

## day 4

Spent way too much time organizing things into folders.  Isn't that always the case?  I took some of the sample 
output from day 2 and moved it to a new project.  Have to admit I was inspried by the aforementioned hilarious 
conversation.  The new project, called dialogs, will be my test reference implementation of the new package.

## day 5

I spent most of the time today working with poetry.  I was trying to figure out the development cycle for building
a new package.  The tricky part is how you get the reference project to update the package after changes.  Once live,
this is done by changing the package version number.  In the end, poetry didn't work how I needed.  The reference
project is back on pipenv and I created a shell script to remove the library, clear the cache, and re-install.

## day 6

Test, tests and more tests.  I created a mock adapter to simulate calling a third party API.  I now have basic
unit tests for paths and nodes, along with one scenario test.  Hopefully, this will help speed up development.

## day 7

Today I refactored the app to use data classes.

## day 8

Added support for cohere generate.  cohere doesn't seems to support context the way openai does so will need
to create a context data structure such that each adapater can map that to the correct data structure.
I new this was coming as soon as I added a second integration.

## day 9

Context class created.  Now used with openai adapter.  Each adapter will need to convert the general Context
class into the specific needs of the API.

Added a way to validate a third party API, which was needed to validate the context changes.  Later we can
automate this to provide a general status on third party API's up-time/status or to monitor if important parts 
of the API have changed.

## day 10

Re-factored adapters to use the context class.

## day 11

Added the common parameters to each adapter (i.e temperature, max_tokens).  If Martin Fowler, author of
*Refactoring: Improving the Design of Existing Code*, saw this work, he'd tell me to re-factor the
handling of these common paramaters into a single function or class.

## day 12

I listened to Martin.  Introduced a base adapater class that handles all common paramaters.  This led
to a furher refinement of the config object.  I suspect some day the config will also become a dataclass.
